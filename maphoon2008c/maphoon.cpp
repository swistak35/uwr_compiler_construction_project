

// Maphoon 2008, written by Hans de Nivelle, June 2008.
// Read the licence before using it. 
//
// Maphoon was used by students in the course Compiler Construction in
// December 2009. After that, I repaired a few bugs in February 2010. 


#include <fstream> 
#include <iostream>
#include <cstdlib>

#include "buildparsercode.h"
#include "parsetable.h" 
#include "grammar.h"
#include "action.h"
#include "attributesystem.h"
#include "cpp.h" 
#include "symbolset.h"
#include "rule.h"
#include "symbol.h"



#include "symbol.stat" 


// A short manual of our system:
// Maphoon has 0 or 1 parameters. In case there is one parameter,
// this is the input file. 
// If there is no parameter, input is read from stdin.
//
// Maphoon creates a definition of struct token in files token.h and
// token.cpp.
// It creates a definition of parser in file parser.h and parser.cpp
// The names of the files cannot be changed, but the namespaces of 
// the parser and token in the program can be set.
//
// 
// Conflicts and Ambiguity. 
// -----------------------
//
//    We depart from the way, in which conflicts are handled in Yacc and in 
//    previous versions of maphoon.
//    In Yacc, conflicts are settled by rule priorities. In maphoon,
//    conflicts are handled by the actions.
//    Each rule action can do 3 things: 
//    1: Return a token of the type lhs of its rule.
//    2: Throw an exception refused.
//    3: Return the start symbol of the grammar. (in which case the parser
//                                                terminates peacefully)
//    In case there is a conflict, maphoon calls the actions of the 
//    reductions one by one. The order is determined by the order in
//    which the rules appear in the grammar. 
//    The first action that does not throw an exception is 
//    carried out. I chose this approach because (1) it seems reasonably
//    simple, and (2) it is very flexible. It allows for dynamic definition
//    of operators, types, etc.
//    It is important to know that an action can see the lookahead, 
//    when making the decision.
// 
//
// %startsymbol S  L1 ... Ln    
//    Defines a start symbol and its lookahead symbols. A start symbol 
//    can have different lookahead symbols. There must be at least one 
//    lookahead symbol for each start symbol. 
// %global p T 
//    Declares a global parameter, p is the name, and T is its type. 
//    Global parameters are parameters of the parser, and they are 
//    passed to every action that uses them (with a declaration of form
//    T& p). 
// %attribute a T 
//    Declares an attribute of token. The attribute has name a, and type T.
//    In maphoon, each attribute is an std::list. This implies 
//    that a token can in principle have an unbounded number of occurrences
//    of every attribute type. 
// %constraint Tok Attr n1 n2.
//    Specifies how many of Attr token Tok can have.
//    One number n1 means : At least n1 occurrences.
//    Two numbers n1, n2 mean: At least n1 occurrences, but strictly 
//    less than n2 occurrences.
//    %constraint FORMULA form 0 1 : Specifies that a FORMULA has exactly
//    one formula.
//    %constraint FORMULALIST form 0 : Specifies that a FORMULALIST can
//    have an unbounded number of formulas.
//    Combinations Tok Attr for which no constraint is defined, cannot
//    occur. 
// %parsernamespace N1:: ... :: Nn 
//    Namespace in which parser is generated. The complete name will be
//    N1::N2::    :: parser(    ) 
//    (Default is empty namespace) 
// %tokennamespace N1::N2 :: ... :: Nn 
//    Namespace in which token is generated. The complete name will be
//    N1::N2 ::    :: token 
//    (Default is empty namespace) 
// %tokenizernamespace N1 :: N2 :: ... :: Nn 
//    Namespace of the tokenizer (the object that reads the tokens) 
//    It should have a method readtoken( ) that returns a token.  
//    (Default is empty namespace) 
// %token T1 T2 T3 ... 
//    Define tokens. It is allowed to use undefined tokens in the grammar,
//    but maphoon gives a warning. 
// %intokenheader S
//    Copy S unchanged into the file token.h. This can be necessary for
//    including the header files of possible attributes of tokens.
// Maphoon internally makes use of the ASSERT makro (in token and parser). 
// ASSERT is also used in the code that is generated by maphoon.
// The user has to define ASSERT by himself. 


namespace
{

   // Read a line from inputstream. If we encounter EOF in a normal
   // fashion, we set eof = true, and return the empty string.
   // If some kind of error occurs, we set error = true.

   std::string readlinefromfile( std::istream& inputstream,
		                 bool& eof,
				 bool& error )
   {
      std::string result;

      char c = inputstream. get( );
      while( c != EOF && c != '\n' && inputstream )
      {
         result. push_back(c);
         c = inputstream. get( );
      }

      if( result. size( ) == 0 && c == EOF )
      {
         eof = true;
         return result;
      }

      if( ! inputstream || c == EOF )
      {
         error = true; 
	 return result; 
      }
      
      return result; 
   }


   void skipwhitespace( const std::string& s, unsigned int& ii )
   {
      while( ii < s. size( ) &&
             ( s[ii] == ' ' || s[ii] == '\t' ))
         ++ ii;
   }


   // Used for C++ type declarations.

   std::string readrestofline( const std::string& s,
		               unsigned int& ii )
   {
      std::string res;

      skipwhitespace( s, ii );

      while( ii < s. size( ))
      {
         res. push_back( s[ii] );
	 ++ ii;
      } 

      unsigned int kk = res. size( ); 
      while( kk != 0 && ( res [ kk - 1 ] == ' ' || res [ kk - 1 ] == '\t' ))
         -- kk; 

      return std::string( res, 0, kk );
   }


   // We don't accept whitespace at this point. Reads a kind
   // of token from s + ii.
   // Note that it is possible that we return the empty string,
   // if we could not read a token.

   std::string readsomething( const std::string& s, unsigned int& ii )
   {
      ASSERT( ii < s. size( ) &&
              s[ii] != ' ' && s[ii] != '\t' );

      if( s[ii] == ';' )
      {
         ++ ii;
	 return std::string( ";" );
      }

      if( s[ii] == ',' )
      {
         ++ ii;
	 return std::string( "," );
      }

      if( s[ii] == ':' )
      {
         ++ ii;
	 return std::string( ":" );
      }

      if( s[ii] == '|' )
      {
         ++ ii;
	 return std::string( "|" );
      }

      if( s[ii] == '/' )
      {
         ++ ii;
         return std::string( "/" );
      }

      if( s[ii] == '%' )
      {
         ++ ii;
	 return std::string( "%" );
      }

      std::string ident;
      while( ii < s. size( ) &&
             ( s[ii] == '_' ||
               ( s[ii] >= '0' && s[ii] <= '9' ) ||
               ( s[ii] >= 'a' && s[ii] <= 'z' ) ||
               ( s[ii] >= 'A' && s[ii] <= 'Z' )))

      { 
         ident. push_back( s[ii] ); 
         ++ ii;
      }
      return ident; 
   }


   // True if s looks like an identifier.

   bool lookslikeidentifier( const std::string& s )
   {
      if( s. size( ))
      {
         for( std::string::const_iterator
                 p = s. begin( );
                 p != s. end( );
                 ++ p )
         {
            if(  ( *p < '0' || *p > '9' ) &&
                 ( *p < 'a' || *p > 'z' ) &&
                 ( *p < 'A' || *p > 'Z' ) &&
                 ( *p != '_' ))
            {
               return false;
            }
         }
         return true;
      }
      else
         return false;
   }


   // We try to read a header. If it succeeds, we return the header
   // without the %
   // If no header could be read, then ii is not changed.
   // A header of " " means that we encountered % followed by
   // whitespace, possibly an empty line. 
   // Empty line means that we did not find a % . 


   std::string tryheader( const std::string& s, 
		          unsigned int& ii )
   {
      unsigned int jj = ii;

      std::string step = readsomething( s, jj );
      if( step == "%" )
      {
	 if( jj == s. size( ) || s[jj] == ' ' || s[jj] == '\t' ) 
	 {
            ii = jj;
	    return std::string( " " );
         }
	 step = readsomething( s, jj );
         ii = jj;
	 return step;
      }
      return std::string( "" );
   }


   // Reads a string of form s1 :: s2 :: ... :: sn, and returns
   // it as a list of strings. We return the emtpy string if 
   // we did not like something.

   std::list< std::string > readnamespace( const std::string& s,
		                           unsigned int& ii )
   {
      std::list< std::string > result;
      unsigned int jj = ii;

      while( jj < s. size( ) &&
                ( s[jj] >= 'a' && s[jj] <= 'z' ) ||
                ( s[jj] >= 'A' && s[jj] <= 'Z' ) ||
	        ( s[jj] >= '0' && s[jj] <= '9' ))
      {
         result. push_back( std::string( ));

	 while( jj < s. size( ) &&
		 ( s[jj] >= '0' && s[jj] <= '9' ) ||
		 ( s[jj] >= 'a' && s[jj] <= 'z' ) ||
		 ( s[jj] >= 'A' && s[jj] <= 'Z' ) ||
		 ( s[jj] == '_' ))
         {
            result. back( ). push_back( s[jj] );
	    ++ jj;
         }

         skipwhitespace( s, jj );
	 if( jj + 2 > s. size( ) ||
             s[jj] != ':' || s[jj+1] != ':' )
         {
            ii = jj; 
            return result;
         }
	 jj += 2;
	 skipwhitespace( s, jj );
      }

      return result; 
   }


   // Reads an unsigned integer. In case no integer can be read,
   // ii will not change. 

   unsigned int readunsigned( const std::string& s,
		              unsigned int& ii )
   {
      unsigned int res = 0;
      while( ii < s. size( ) &&
                ( s[ii] >= '0' && s[ii] <= '9' ))
      {
         res *= 10;
	 res += ( s[ii] - '0' );
         ++ ii;
      }
      return res;
   }


}


int main( int nrargs, char* ( args [] ) )
{

   // First step: We check if there is a parameter. If there
   // is a parameter, then it determines the inputfile. 

   std::string inputfilename;
      // If the string is empty, input comes from std::cin.
   std::istream* inputstream = 0;

   if( nrargs == 0 )
   {
      std::cout << "ERROR: there must be at least one parameter\n\n";
      exit(0);
   }

   if( nrargs > 2 )
   {
      std::cout << "ERROR: there are too many parameters\n\n";
      exit(0);
   }

   if( nrargs == 2 )
   {
      inputfilename = args [1]; 
      inputstream = new std::ifstream( inputfilename. c_str( ));
      if( ! ( *inputstream ))
      {
         std::cout << "ERROR: ";
	 std::cout << "could not open inputfile " << inputfilename << "\n\n";
	 exit(0);
      }
   }
   else
      inputstream = & std::cin;


   // A few more parameters:

   std::list< std::string > parsernamespace;
   std::list< std::string > tokennamespace;
   std::list< std::string > tokenizernamespace;
   std::list< std::string > intokenheader;

   std::ofstream parserstream( "parser.cpp" );
   if( !parserstream )
   {
      std::cout << "unable to open parser.cpp for writing\n";
      return 1;
   }

   parserstream << "\n";
   parserstream << "// Parser generated by Maphoon 2008\n";
   parserstream << "\n\n";
   parserstream << "#line 1\n"; 

   grammar gram; 

   globalvariables glob;
   attributesystem attr;
   symbolset usedsymbols;
      // These are the symbols that are needed by the parser.
      // We will collect here the declared symbols, the symbols
      // that occur in the grammar and a few special symbols. 

   // Now we are ready to collect more input:

   unsigned int linecount = 0;
   bool eof = false;
   while( true )
   {

      bool error = false; 
      std::string thisline = readlinefromfile( *inputstream, eof, error ); 

      ++ linecount;
      if( error )
      {
         std::cout << "ERROR: problems with input file";
	 goto error;
      }

      if( eof )
         goto inputcomplete; 

      unsigned int ii = 0;
      skipwhitespace( thisline, ii );

      std::string header;
      if( ii < thisline. size( ))
         header = tryheader( thisline, ii );

      if( header. size( ))
      {
         // We have something special:

	 if( header == "startsymbol" )
         {
            skipwhitespace( thisline, ii ); 

            if( ii == thisline. size( ))
            {
               std::cout << "ERROR: start symbol expected";
	       goto error;
            }
            std::string start = readsomething( thisline, ii );

            if( ! lookslikeidentifier( start ))
            {
               std::cout << "ERROR: start symbol expected";
               goto error;
            }

            skipwhitespace( thisline, ii );

            while( ii != thisline. size( ))
            {
               std::string lookahead = readsomething( thisline, ii );
               if( ! lookslikeidentifier( lookahead ))
               {
                  std::cout << "ERROR: look ahead symbol expected";
                  goto error;
               }

               gram. insert( symbol( start ), symbol( lookahead ));

               skipwhitespace( thisline, ii );
            }
	    goto lineread; 
         }

         if( header == "global" )
         {
            skipwhitespace( thisline, ii );
            if( ii == thisline. size( ))
            {
               std::cout << "ERROR: global parameter expected";
               goto error;
            }

            std::string name = readsomething( thisline, ii );
            if( ! lookslikeidentifier( name ))
            {
               std::cout << "ERROR: global parameter expected";
               goto error;
            }

            skipwhitespace( thisline, ii );
            if( ii == thisline. size( ))
            {
               std::cout << "ERROR: type of global parameter expected";
               goto error;
            }

            std::string nametype = readrestofline( thisline, ii );
            if( ii != thisline. size( ))
            {
               std::cout << "ERROR: end of line expected";
               goto error;
            }

            glob. add( nametype, name ); 
            goto lineread;
         }

	 if( header == "attribute" )
         {
            skipwhitespace( thisline, ii );
	    if( ii == thisline. size( ))
            {
               std::cout << "ERROR: attributename expected";
	       goto error;
            }
	    std::string name = readsomething( thisline, ii );
            if( ! lookslikeidentifier( name ))
            {
               std::cout << "ERROR: attribute name expected";
               goto error;
            }
	    skipwhitespace( thisline, ii );
	    if( ii == thisline. size( ))
            {
               std::cout << "ERROR: attribute type expected";
	       goto error;
            }
             
            std::string nametype = readrestofline( thisline, ii );
            if( ii != thisline. size( ))
            {
               std::cout << "ERROR: end of line expected";
               goto error;
            }

            if( attr. isattribute( name ))
            {
               std::cout << "ERROR: attribute redeclared";
               goto error;
            }
	    attr. addattribute( name, nametype );
	    goto lineread;
         }
		     
         if( header == "constraint" )
         {
            skipwhitespace( thisline, ii );
            if( ii == thisline. size( ))
            {
               std::cout << "ERROR: attribute name expected";
               goto error;
            }
            std::string name = readsomething( thisline, ii );
            if( ! lookslikeidentifier( name ))
            {
               std::cout << "ERROR: symbol expected";
               goto error;
            }
            symbol symb = symbol( name );

            skipwhitespace( thisline, ii );
            if( ii == thisline. size( ))
            {
               std::cout << "attribute name expected";
               goto error;
            }
            name = readsomething( thisline, ii );
            if( ! lookslikeidentifier( name ))
            {
               std::cout << "attribute name expected";
               goto error;
            }

            if( ! attr. isattribute( name ))
            {
               std::cout << "ERROR: attribute was not declared as attribute";
               goto error;
            }

            if( attr. hasconstraint( symb, name ))
            {
               std::cout << "ERROR: redefinition of constraint";
               goto error; 
            }

            skipwhitespace( thisline, ii ); 

            if( ii == thisline. size( ) ||
                ( thisline [ii] < '0' && thisline [ii] > '9' ))
            {
               std::cout << "ERROR: numerical constraint expected";
               goto error;
            }

            unsigned int c1 = readunsigned( thisline, ii );
            skipwhitespace( thisline, ii );
            if( ii == thisline. size( ))
            {
               // This is OK. It means that there is only one constraint.
           
               attr. addconstraint( symb, name, c1 );
               goto lineread;
            }

            if( thisline[ii] >= '0' && thisline[ii] <= '9' )
            {
               unsigned int c2 = readunsigned( thisline, ii );
               skipwhitespace( thisline, ii );
               if( ii != thisline. size( ))
               {
                  std::cout << "ERROR: end of line expected";
                  goto error;
               }
               attr. addconstraint( symb, name, c1, c2 );
               goto lineread; 
            }

            std::cout << "ERROR: numerical constraint expected";
            goto error; 
         }
 
	 if( header == "parsernamespace" )
         {
            skipwhitespace( thisline, ii ); 
            if( parsernamespace. size( ))
            {
               std::cout << "ERROR: redefinition of parser namespace";
	       goto error;
            }

	    parsernamespace = readnamespace( thisline, ii );
	    skipwhitespace( thisline, ii );
	    if( ii != thisline. size( ))
            {
               std::cout << "ERROR: end of line expected";
	       goto error;
            }
	    goto lineread;
         }

	 if( header == "tokennamespace" )
         {
            skipwhitespace( thisline, ii ); 
            if( tokennamespace. size( ))
            {
               std::cout << "ERROR: redefinition of token namespace";
	       goto error;
            }

	    tokennamespace = readnamespace( thisline, ii );
	    skipwhitespace( thisline, ii );
	    if( ii != thisline. size( ))
            {
               std::cout << "ERROR: end of line expected";
	       goto error;
            }
	    goto lineread; 
         }

	 if( header == "tokenizernamespace" )
         {
            skipwhitespace( thisline, ii );
            if( tokenizernamespace. size( ))
            {
               std::cout << "ERROR: redefinition of tokenizer namespace";
	       goto error;
            }

	    tokenizernamespace = readnamespace( thisline, ii );
	    skipwhitespace( thisline, ii );
	    if( ii != thisline. size( ))
            {
               std::cout << "ERROR: end of line expected";
	       goto error;
            }
	    goto lineread;
         }

         if( header == "token" )
         {
            skipwhitespace( thisline, ii );
            while( ii != thisline. size( ))
            {
               std::string something = readsomething( thisline, ii );
               if( ! lookslikeidentifier( something ))
               {
                  std::cout << "ERROR: expected symbol declaration";
                  goto error;
               }
               
               usedsymbols. insert( symbol( something ));
               
               skipwhitespace( thisline, ii );
            }
            goto lineread;
         }

         if( header == "intokenheader" )
         {
            skipwhitespace( thisline, ii );

            if( ii == thisline. size( ))
            {
               std::cout << "ERROR: expected something to include in token.h";
               goto error;
            }

            intokenheader. push_back( readrestofline( thisline, ii ));
            if( ii != thisline. size( ))
            {
               std::cout << "ERROR: end of line expected";
               goto error;
            }

            goto lineread;
         }

         if( header == " " )
         {

            skipwhitespace( thisline, ii );
            if( ii == thisline. size( ))
            {
               std::cout << "ERROR: expected grammar rule\n";
               goto error;
            }
            std::string something = readsomething( thisline, ii );
            if( ! lookslikeidentifier( something ))
            {
               std::cout << "ERROR: expected grammar rule\n";
               goto error;
            }

            symbol lhs = symbol( something );
	    skipwhitespace( thisline, ii );

            if( ii == thisline. size( ))
            {
               std::cout << "ERROR: expected ':'";
               goto error;
            }

	    something = readsomething( thisline, ii );
            if( something != ":" )
            {
               std::cout << "ERROR: expected ':'";
	       goto error;
            }

         readrhs: 
	    {
	       std::list< symbol > rhs;
               action act = action( inputfilename. size( ) ? 
			            inputfilename :
                                    std::string( "std::cin" ),
				    linecount );

            readrhssymbols:
	       skipwhitespace( thisline, ii ); 
	       if( ii == thisline. size( )) goto readactions;
	       something = readsomething( thisline, ii );
	       if( something == "/" )
               {
                  skipwhitespace( thisline, ii );
		  goto readactions;
               }

               if( ! lookslikeidentifier( something ))
               {
                  std::cout << "ERROR: rhs symbol expected";
                  goto error;
               }

	       rhs. push_back( symbol( something ));
	       goto readrhssymbols;

            readactions:
               skipwhitespace( thisline, ii );
	       if( ii < thisline. size( ) && thisline[ii] == '%' )
                  goto rhscomplete;

	       act. addline( readrestofline( thisline, ii ));
	       thisline = readlinefromfile( *inputstream, eof, error );
               
               if( eof )
               {
                  std::cout << "ERROR: encountered EOF inside grammar rule";
                  goto error;
               }

               if( error )
               {
                  std::cout << "ERROR: cannot read from input file";
                  goto error;
               }

	       ++ linecount; 
               ii = 0;
	       goto readactions;

            rhscomplete:
               gram. insert( rule( lhs, rhs, 0 ), act );
            }

            // We now can have % ; or % | .

	    ++ ii;
	    skipwhitespace( thisline, ii );
	    if( ii == thisline. size( ) ||
                ( thisline[ii] != ';' && thisline[ii] != '|' ))
            {
               std::cout << "ERROR: expected ';' or '|'";
	       goto error;
            }
	    
            if( thisline[ii] == '|' )
            {
               ++ ii;
	       goto readrhs;
            }

            // We know for sure that thisline [ii] = ';'.

            ++ ii;
	    skipwhitespace( thisline, ii );
	    if( ii != thisline. size( ))
            {
               std::cout << "ERROR: end of line expected";
	       goto error;
            }

            goto lineread;

         }

         // We encountered a %, but did not recognize the command.

         std::cout << "ERROR: command %" << header << " was not recognized";
         goto error;

      }
      else
      {
         // Lines that are not special are simply copied into parser.cpp 

         if( !parserstream )
         {
            std::cout << "ERROR: there is a problem with parser.cpp\n"; 
	    goto error;
         }

	 parserstream << thisline << "\n";
      }
   lineread:
      ;
   }

inputcomplete: 
   {

   // Print the grammar:

   std::cout << gram << "\n";

   std::cout << "declared symbols: " << usedsymbols << "\n\n";

   std::cout << "tokens occurring left:\n";
   std::cout << "   " << gram. leftsymbols( ) << "\n\n";

   std::cout << "tokens occurring right:\n";
   std::cout << "   " << gram. rightsymbols( ) << "\n\n";

   {
      // We will compare the declared symbols with the symbols
      // that occur in the grammar.

      symbolset s = usedsymbols;
      s. remove( gram. allsymbols( ));

      if( s. size( ))
      {
         std::cout << "declared symbols that do not occur in grammar: ";
         std::cout << s << "\n\n";
      }

      s = gram. allsymbols( );
      s. remove( usedsymbols );

      if( s. size( ))
      {
         std::cout << "symbols that occur in grammar without declaration: ";
         std::cout << s << "\n\n";
      }

      // We check that the lookahead symbols are not reachable from
      // the start symbols:

      std::map< symbol, symbolset > reach = gram. reachabilitysets( );
      unsigned int reacherror = 0;
      for( std::map< symbol, symbolset > :: const_iterator
              p = gram. starts. begin( ); 
              p != gram. starts. end( );
              ++ p )
      { 
         const symbolset& s = reach [ p -> first ];
         for( symbolset::const_iterator
                 q = s. begin( );
                 q != s. end( );
                 ++ q )
         {
            if( p -> second. contains( *q ))
            {
               std::cout << "lookahead symbol " << *q << " is reachable ";
               std::cout << "from start symbol " << ( p -> first ) <<  "\n";
               ++ reacherror;
            }
         }
      }
 
      if( reacherror )
         return 0;  
             
   }

   // Print the attribute system: 

   std::cout << attr << "\n";

   // Print the global variables:

   std::cout << glob << "\n";

   parsetable pt = parsetable::construct( gram );
   pt. setdefaultreductions( ); 

   std::cout << pt << "\n";

   pt. printconflicts( std::cout ); 
   std::cout << "\n\n";

   // We now collect all tokens in usedsymbols.

   usedsymbols. insert( gram. allsymbols( ));
   usedsymbols. insert( symbol::recover );
   usedsymbols. insert( symbol::defaultred );

   {
      std::ofstream tok( "token.h" );
      if( !tok )
      {
         std::cout << "could not open token.h";
         goto error; 
      }

      attr. printtokendecl( usedsymbols, 
                            tok, tokennamespace, "token",
                            intokenheader );
   }

   {
      std::ofstream tok( "token.cpp" );
      if( !tok )
      {
         std::cout << "could not open token.cpp";
         goto error;
      }

      attr. printtokencode( usedsymbols, 
                            tok, tokennamespace, "token" );
   }

   {
      std::ofstream parse( "parser.h" );
      if( !parse )
      {
         std::cout << "could not open parser.h";
         goto error; 
      }
      
      buildparsercode::builddeclaration( 
                            parsernamespace, tokennamespace,
                            tokenizernamespace, glob, parse );
   }

   try
   { 
      buildparsercode::builddefinition( 
                               parsernamespace, tokennamespace, 
                               tokenizernamespace, gram, pt, 
                               glob, parserstream );
   }
   catch( actionerror error )
   {
      std::cout << error << "\n\n";
      return 0; 
   }

   std::cout << "ended normally"; 
   }

error:
   std::cout << " in line " << linecount << "\n\n";
   return 0; 
}


